{% extends "base.html" %}

{% block topbar_actions %}
  <a class="btn btn-secondary" href="{{ url_for('agents.list_nodes') }}">
    <i class="fa-solid fa-arrow-left"></i>
    back to nodes
  </a>
{% endblock %}

{% block content %}
<div
  class="task-detail-panels"
  id="task-detail-root"
  data-task-id="{{ task.id }}"
  data-task-status="{{ task.status }}"
  data-task-status-url="{{ url_for('agents.node_status', task_id=task.id) }}"
>
  <section class="card">
    <div class="card-header">
      <div>
        <p class="eyebrow">node {{ task.id }}</p>
        <h2 class="section-title">{{ task_kind_label(task.kind) }}</h2>
      </div>
      <div class="row">
        {% if task.status == "running" %}
          <span class="status status-running" id="task-status">running</span>
        {% elif task.status == "queued" %}
          <span class="status status-queued" id="task-status">queued</span>
        {% elif task.status == "pending" %}
          <span class="status status-queued" id="task-status">pending</span>
        {% elif task.status == "succeeded" %}
          <span class="status status-success" id="task-status">succeeded</span>
        {% elif task.status == "failed" %}
          <span class="status status-failed" id="task-status">failed</span>
        {% else %}
          <span class="status status-idle" id="task-status">{{ task.status }}</span>
        {% endif %}
      </div>
    </div>
    {% if task.status in ["queued", "running"] %}
      <div class="row" style="margin-top: 16px; gap: 10px; flex-wrap: wrap;">
        <form
          method="post"
          action="{{ url_for('agents.cancel_node', task_id=task.id) }}"
        >
          <input type="hidden" name="next" value="{{ request.path }}" />
          <button type="submit" class="btn btn-secondary">
            <i class="fa-solid fa-stop"></i>
            cancel
          </button>
        </form>
      </div>
    {% endif %}
    <div class="grid grid-2" style="margin-top: 20px;">
      <div class="subcard">
        <p class="eyebrow">context</p>
        <div class="stack" style="margin-top: 12px; font-size: 12px;">
          {% set quick_rag_source_name = quick_rag_task_context.get("source_name") if quick_rag_task_context else "" %}
          <p class="muted">
            Agent:
            {% if agent %}
              <a href="{{ url_for('agents.view_agent', agent_id=agent.id) }}">{{ agent.name }}</a>
            {% elif is_quick_rag_task %}
              Sources quick run{% if quick_rag_source_name %} ({{ quick_rag_source_name }}){% endif %}
            {% elif is_quick_task and task.agent_id is none %}
              Quick Node (default profile)
            {% elif task.agent_id is none %}
              -
            {% else %}
              Agent {{ task.agent_id }}
            {% endif %}
          </p>
          <p class="muted">
            Task:
            {% if template %}
              <a href="{{ url_for('agents.view_task_template', template_id=template.id) }}">{{ template.name }}</a>
            {% elif task.task_template_id %}
              Task {{ task.task_template_id }}
            {% else %}
              -
            {% endif %}
          </p>
          <p class="muted">
            Model:
            {% if task.model %}
              <a href="{{ url_for('agents.view_model', model_id=task.model.id) }}">{{ task.model.name }}</a>
            {% elif task.model_id %}
              Model {{ task.model_id }}
            {% else %}
              -
            {% endif %}
          </p>
          <p class="muted">
            MCP servers:
            {% if task.mcp_servers %}
              {% for server in task.mcp_servers %}
                <a href="{{ url_for('agents.view_mcp', mcp_id=server.id) }}">{{ server.name }}</a>{% if not loop.last %}, {% endif %}
              {% endfor %}
            {% else %}
              -
            {% endif %}
          </p>
          <p class="muted">
            Integrations:
            {% if selected_integration_labels %}
              {{ selected_integration_labels|join(", ") }}
              {% if task_integrations_legacy_default %}
                (legacy default)
              {% endif %}
            {% else %}
              -
            {% endif %}
          </p>
          <p class="muted">
            Node scripts:
            {% if task.scripts %}
              {% for script in task.scripts %}
                <a href="{{ url_for('agents.view_script', script_id=script.id) }}">
                  {{ script.file_name }}
                </a>
                ({{ script_type_label(script.script_type) }}){% if not loop.last %}, {% endif %}
              {% endfor %}
            {% else %}
              -
            {% endif %}
          </p>
          {% if task.attachments %}
            <p class="muted">Attachments:</p>
            {% for attachment in task.attachments %}
              <div class="row" style="gap: 8px; align-items: center;">
                <p class="muted" style="margin: 0;">
                  {{ attachment.file_name }} {% if attachment.file_path %}({{ attachment.file_path }}){% endif %}
                </p>
                {% if is_quick_task %}
                  <form
                    method="post"
                    action="{{ url_for('agents.remove_node_attachment', task_id=task.id, attachment_id=attachment.id) }}"
                    onsubmit="return confirm('Remove this attachment?');"
                  >
                    <input type="hidden" name="next" value="{{ request.path }}" />
                    <button type="submit" class="btn btn-secondary" style="padding: 4px 10px;">
                      remove
                    </button>
                  </form>
                {% endif %}
              </div>
            {% endfor %}
          {% else %}
            <p class="muted">Attachments: -</p>
          {% endif %}
          <p class="muted">
            Autorun node:
            <span id="task-run-task-id">{{ task.run_task_id or "-" }}</span>
          </p>
        </div>
      </div>
      <div class="subcard">
        <p class="eyebrow">timing</p>
        <div class="stack" style="margin-top: 12px; font-size: 12px;">
          <p class="muted">
            Created:
            <span id="task-created-at">{{ human_time(task.created_at) }}</span>
          </p>
          <p class="muted">
            Started:
            <span id="task-started-at">{{ human_time(task.started_at) }}</span>
          </p>
          <p class="muted">
            Finished:
            <span id="task-finished-at">{{ human_time(task.finished_at) }}</span>
          </p>
          <p class="muted">
            Celery task:
            <span id="task-celery-id">{{ task.celery_task_id or "-" }}</span>
          </p>
        </div>
      </div>
    </div>
    {% if task.status in ["queued", "running"] %}
      <p class="muted" id="task-auto-refresh" style="margin-top: 16px;">
        Realtime updates active. Polling fallback starts only if socket connectivity fails.
      </p>
    {% endif %}
  </section>

  <section class="card">
    <details id="task-prompt-details" data-task-id="{{ task.id }}">
      <summary
        class="collapse-summary"
        style="display: flex; flex-direction: column; align-items: stretch; gap: 12px;"
      >
        <div class="card-header">
          <div class="row" style="gap: 10px; align-items: center;">
            <i class="fa-solid fa-chevron-right collapse-icon" aria-hidden="true"></i>
            <h2 class="section-title">Prompt</h2>
          </div>
          <div class="row" style="gap: 8px; align-items: center;">
            <button
              type="button"
              class="btn btn-secondary"
              id="task-prompt-copy"
              data-copy-target="task-prompt-text"
              data-copy-label="Copy Prompt"
              data-copy-success="Copied"
              aria-label="Copy prompt"
              title="Copy prompt"
              {% if not prompt_text %}disabled{% endif %}
              style="padding: 6px 12px; font-size: 10px; letter-spacing: 0.2em;"
            >
              Copy Prompt
            </button>
            <button
              type="button"
              class="btn btn-secondary"
              id="task-prompt-json-copy"
              data-copy-target="task-prompt-json"
              data-copy-label="Copy JSON"
              data-copy-success="Copied"
              aria-label="Copy JSON"
              title="Copy JSON"
              {% if not prompt_json %}disabled{% endif %}
              style="padding: 6px 12px; font-size: 10px; letter-spacing: 0.2em;"
            >
              Copy JSON
            </button>
          </div>
        </div>
        {% if prompt_text %}
          <div
            id="task-prompt-text-rendered"
            class="log-output markdown-content"
            data-markdown-target="task-prompt-text"
            style="margin: 0;"
          ></div>
          <pre id="task-prompt-text" style="display: none;">{{ prompt_text }}</pre>
        {% else %}
          <p class="muted" style="margin: 0;">No prompt recorded.</p>
        {% endif %}
      </summary>
      {% if prompt_json %}
        <div style="margin-top: 12px;">
          <p class="eyebrow" style="margin-bottom: 8px;">full json</p>
          <pre id="task-prompt-json" style="white-space: pre-wrap;">{{ prompt_json }}</pre>
        </div>
      {% else %}
        <p class="muted" style="margin-top: 12px;">No JSON payload recorded.</p>
      {% endif %}
    </details>
  </section>
</div>

<section class="card">
  <details id="task-output-details" {% if task_output %}open{% endif %}>
    <summary class="card-header collapse-summary">
      <div class="row" style="gap: 10px; align-items: center;">
        <i class="fa-solid fa-chevron-right collapse-icon" aria-hidden="true"></i>
        <h2 class="section-title">Output</h2>
      </div>
      <button
        type="button"
        class="btn btn-secondary"
        id="task-output-copy"
        data-copy-target="task-output"
        data-copy-label="copy"
        data-copy-success="copied"
        aria-label="Copy output"
        title="Copy output"
        {% if not task_output %}disabled{% endif %}
        style="padding: 6px 12px; font-size: 10px; letter-spacing: 0.2em;"
      >
        copy
      </button>
    </summary>
    <div
      id="task-output-rendered"
      class="log-output markdown-content"
      data-markdown-target="task-output"
      style="margin-top: 12px;{% if not task_output %} display: none;{% endif %}"
    ></div>
    <pre id="task-output" style="display: none;">{{ task_output }}</pre>
    <p
      class="muted"
      id="task-output-empty"
      style="margin-top: 12px;{% if task_output %} display: none;{% endif %}"
    >
      No output yet.
    </p>
  </details>
</section>

<section class="card">
  <div class="card-header">
    <h2 class="section-title">Stages</h2>
  </div>
  {% if stage_entries %}
    <div class="stack" id="task-stage-list" style="margin-top: 12px; gap: 12px;">
      {% for stage in stage_entries %}
        <details
          class="subcard"
          data-stage-key="{{ stage.key }}"
          {% if task.status in ["succeeded", "failed", "canceled", "stopped"] or stage.status == "running" %}
            open
          {% endif %}
        >
          <summary class="row collapse-summary" style="justify-content: space-between; align-items: center;">
            <div class="row" style="gap: 8px; align-items: center;">
              <i class="fa-solid fa-chevron-right collapse-icon" aria-hidden="true"></i>
              <p class="eyebrow">{{ stage.label }}</p>
            </div>
            <div class="row" style="gap: 8px; align-items: center;">
              <button
                type="button"
                class="btn btn-secondary"
                data-action="copy-stage-logs"
                data-copy-label="copy"
                data-copy-success="copied"
                aria-label="Copy {{ stage.label }} logs"
                style="padding: 6px 12px; font-size: 10px; letter-spacing: 0.2em;"
              >
                copy
              </button>
              <span class="status {{ stage.status_class }}" data-role="stage-status">
                {{ stage.status_label }}
              </span>
            </div>
          </summary>
          <div
            class="log-output markdown-content"
            data-role="stage-logs"
            data-markdown-target="self"
            style="margin-top: 12px;{% if not stage.logs %} display: none;{% endif %}"
          >{{ stage.logs }}</div>
          <p
            class="muted"
            data-role="stage-empty"
            style="margin-top: 12px;{% if stage.logs %} display: none;{% endif %}"
          >
            No logs yet.
          </p>
        </details>
      {% endfor %}
    </div>
  {% else %}
    <p class="muted" style="margin-top: 12px;">No stage data yet.</p>
  {% endif %}
</section>
<script>
  (() => {
    const escapeHtml = (value) =>
      String(value || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");

    const sanitizeUrl = (rawValue) => {
      const raw = String(rawValue || "").trim();
      if (!raw) {
        return null;
      }
      if (
        raw.startsWith("/") ||
        raw.startsWith("#") ||
        raw.startsWith("./") ||
        raw.startsWith("../")
      ) {
        return raw;
      }
      try {
        const parsed = new URL(raw);
        if (["http:", "https:", "mailto:"].includes(parsed.protocol)) {
          return parsed.toString();
        }
      } catch (error) {
      }
      return null;
    };

    const renderInline = (value) => {
      if (!value) {
        return "";
      }
      const inlineCodeTokens = [];
      let rendered = value.replace(/`([^`\n]+)`/g, (_, code) => {
        const token = `@@INLINE_CODE_${inlineCodeTokens.length}@@`;
        inlineCodeTokens.push(`<code>${code}</code>`);
        return token;
      });

      rendered = rendered.replace(
        /\[([^\]]+)\]\(([^)\s]+)(?:\s+"([^"]*)")?\)/g,
        (_, label, href, title) => {
          const safeHref = sanitizeUrl(href);
          const labelText = label || href;
          if (!safeHref) {
            return labelText;
          }
          const escapedHref = escapeHtml(safeHref);
          const escapedTitle = title ? ` title="${escapeHtml(title)}"` : "";
          return `<a href="${escapedHref}"${escapedTitle} target="_blank" rel="noopener noreferrer">${labelText}</a>`;
        },
      );
      rendered = rendered.replace(/\*\*([^*\n]+)\*\*/g, "<strong>$1</strong>");
      rendered = rendered.replace(/\*([^*\n]+)\*/g, "<em>$1</em>");
      rendered = rendered.replace(/~~([^~\n]+)~~/g, "<del>$1</del>");

      return rendered.replace(/@@INLINE_CODE_(\d+)@@/g, (_, index) => {
        const token = inlineCodeTokens[Number(index)];
        return token || "";
      });
    };

    const renderMarkdown = (rawValue) => {
      const normalized = String(rawValue || "").replace(/\r\n/g, "\n");
      if (!normalized.trim()) {
        return "";
      }
      const escaped = escapeHtml(normalized);
      const codeBlockTokens = [];
      let working = escaped.replace(
        /```([A-Za-z0-9_+-]*)[ \t]*\n?([\s\S]*?)```/g,
        (_, language, code) => {
          const token = `@@CODE_BLOCK_${codeBlockTokens.length}@@`;
          const className = language
            ? ` class="language-${escapeHtml(language)}"`
            : "";
          const codeBody = code.endsWith("\n") ? code.slice(0, -1) : code;
          codeBlockTokens.push(`<pre><code${className}>${codeBody}</code></pre>`);
          return token;
        },
      );

      const blocks = working
        .split(/\n{2,}/)
        .map((block) => block.trim())
        .filter(Boolean);

      const renderedBlocks = blocks.map((block) => {
        if (/^@@CODE_BLOCK_\d+@@$/.test(block)) {
          return block;
        }
        if (/^([-*_]\s*){3,}$/.test(block)) {
          return "<hr />";
        }
        const heading = block.match(/^(#{1,6})\s+(.+)$/);
        if (heading) {
          const level = heading[1].length;
          const text = renderInline(heading[2].trim());
          return `<h${level}>${text}</h${level}>`;
        }

        const lines = block.split("\n");
        if (lines.every((line) => /^\s*[-*]\s+/.test(line))) {
          const items = lines
            .map((line) => line.replace(/^\s*[-*]\s+/, ""))
            .map((line) => `<li>${renderInline(line)}</li>`)
            .join("");
          return `<ul>${items}</ul>`;
        }
        if (lines.every((line) => /^\s*\d+\.\s+/.test(line))) {
          const items = lines
            .map((line) => line.replace(/^\s*\d+\.\s+/, ""))
            .map((line) => `<li>${renderInline(line)}</li>`)
            .join("");
          return `<ol>${items}</ol>`;
        }
        if (lines.every((line) => /^\s*>\s?/.test(line))) {
          const quote = lines
            .map((line) => line.replace(/^\s*>\s?/, ""))
            .map((line) => renderInline(line))
            .join("<br>");
          return `<blockquote>${quote}</blockquote>`;
        }
        return `<p>${lines.map((line) => renderInline(line)).join("<br>")}</p>`;
      });

      const html = renderedBlocks.join("\n");
      return html.replace(/@@CODE_BLOCK_(\d+)@@/g, (_, index) => {
        const token = codeBlockTokens[Number(index)];
        return token || "";
      });
    };

    const renderInto = (targetEl, rawValue) => {
      if (!targetEl) {
        return;
      }
      const value = typeof rawValue === "string" ? rawValue : "";
      targetEl.dataset.rawMarkdown = value;
      targetEl.innerHTML = renderMarkdown(value);
    };

    const rawFrom = (targetEl) => {
      if (!targetEl) {
        return "";
      }
      if (typeof targetEl.dataset.rawMarkdown === "string") {
        return targetEl.dataset.rawMarkdown;
      }
      return targetEl.textContent || "";
    };

    const renderAll = () => {
      document.querySelectorAll("[data-markdown-target]").forEach((targetEl) => {
        const sourceId = targetEl.getAttribute("data-markdown-target");
        if (sourceId === "self") {
          renderInto(targetEl, rawFrom(targetEl));
          return;
        }
        const sourceEl = sourceId ? document.getElementById(sourceId) : null;
        renderInto(targetEl, sourceEl ? sourceEl.textContent : "");
      });
    };

    window.llmctlMarkdown = { renderInto, rawFrom, renderAll };
    renderAll();
  })();
</script>
<script>
  (() => {
    const stageList = document.getElementById("task-stage-list");
    if (!stageList) {
      return;
    }

    const copyText = async (text) => {
      if (window.navigator?.clipboard?.writeText) {
        try {
          await window.navigator.clipboard.writeText(text);
          return true;
        } catch (error) {
        }
      }
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.setAttribute("readonly", "");
      textarea.style.position = "absolute";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      let copied = false;
      try {
        copied = document.execCommand("copy");
      } catch (error) {
        copied = false;
      }
      document.body.removeChild(textarea);
      return copied;
    };

    stageList.addEventListener("click", async (event) => {
      const button = event.target.closest('[data-action="copy-stage-logs"]');
      if (!button) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();

      const details = button.closest("[data-stage-key]");
      if (!details) {
        return;
      }
      const logsEl = details.querySelector('[data-role="stage-logs"]');
      const logsText = window.llmctlMarkdown
        ? window.llmctlMarkdown.rawFrom(logsEl)
        : (logsEl ? logsEl.textContent : "");
      const defaultLabel = button.getAttribute("data-copy-label") || "copy";
      const successLabel = button.getAttribute("data-copy-success") || "copied";

      const copied = await copyText(logsText);
      if (!copied) {
        return;
      }
      button.textContent = successLabel;
      button.disabled = true;
      window.setTimeout(() => {
        button.textContent = defaultLabel;
        button.disabled = false;
      }, 1200);
    });
  })();
</script>
<script>
  (() => {
    const copyButtons = document.querySelectorAll("[data-copy-target]");
    if (!copyButtons.length) {
      return;
    }

    const copyText = async (text) => {
      if (window.navigator?.clipboard?.writeText) {
        try {
          await window.navigator.clipboard.writeText(text);
          return true;
        } catch (error) {
        }
      }
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.setAttribute("readonly", "");
      textarea.style.position = "absolute";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      let copied = false;
      try {
        copied = document.execCommand("copy");
      } catch (error) {
        copied = false;
      }
      document.body.removeChild(textarea);
      return copied;
    };

    const flashCopyState = (button) => {
      const defaultLabel = button.getAttribute("data-copy-label") || "copy";
      const successLabel = button.getAttribute("data-copy-success") || "copied";
      const wasDisabled = button.disabled;

      button.textContent = successLabel;
      button.disabled = true;
      button.setAttribute("aria-label", successLabel);
      button.setAttribute("title", successLabel);

      window.setTimeout(() => {
        button.textContent = defaultLabel;
        button.disabled = wasDisabled;
        button.setAttribute("aria-label", defaultLabel);
        button.setAttribute("title", defaultLabel);
      }, 1200);
    };

    copyButtons.forEach((button) => {
      button.addEventListener("click", async (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (button.disabled) {
          return;
        }
        const targetId = button.getAttribute("data-copy-target");
        const targetEl = targetId ? document.getElementById(targetId) : null;
        const text = targetEl ? targetEl.textContent : "";
        if (!text) {
          return;
        }
        const copied = await copyText(text);
        if (copied) {
          flashCopyState(button);
        }
      });
    });
  })();
</script>
<script>
  (() => {
    const promptDetails = document.getElementById("task-prompt-details");
    if (!promptDetails) {
      return;
    }
    const taskId = promptDetails.getAttribute("data-task-id");
    if (!taskId) {
      return;
    }
    const storageKey = `task-detail:${taskId}:prompt-open`;
    const storedState = window.localStorage.getItem(storageKey);
    if (storedState === "open") {
      promptDetails.open = true;
    } else if (storedState === "closed") {
      promptDetails.open = false;
    }
    promptDetails.addEventListener("toggle", () => {
      window.localStorage.setItem(storageKey, promptDetails.open ? "open" : "closed");
    });
  })();
</script>
{% if task.status in ["queued", "running"] %}
  <script>
    (() => {
      const root = document.getElementById("task-detail-root");
      if (!root) {
        return;
      }
      const statusUrl = root.getAttribute("data-task-status-url") || "";
      const statusEl = document.getElementById("task-status");
      const outputDetailsEl = document.getElementById("task-output-details");
      const outputRenderedEl = document.getElementById("task-output-rendered");
      const outputEl = document.getElementById("task-output");
      const outputEmptyEl = document.getElementById("task-output-empty");
      const outputCopyButton = document.getElementById("task-output-copy");
      const autoRefreshEl = document.getElementById("task-auto-refresh");
      const startedAtEl = document.getElementById("task-started-at");
      const finishedAtEl = document.getElementById("task-finished-at");
      const createdAtEl = document.getElementById("task-created-at");
      const runTaskIdEl = document.getElementById("task-run-task-id");
      const celeryIdEl = document.getElementById("task-celery-id");
      const stageNodes = new Map();

      document.querySelectorAll("[data-stage-key]").forEach((details) => {
        const key = details.getAttribute("data-stage-key");
        if (!key) {
          return;
        }
        stageNodes.set(key, {
          details,
          statusEl: details.querySelector('[data-role="stage-status"]'),
          logsEl: details.querySelector('[data-role="stage-logs"]'),
          emptyEl: details.querySelector('[data-role="stage-empty"]'),
        });
      });

      const statusClasses = {
        running: "status-running",
        queued: "status-queued",
        pending: "status-queued",
        succeeded: "status-success",
        failed: "status-failed",
        canceled: "status-idle",
        stopped: "status-idle",
      };

      const updateText = (el, value, fallback = "-") => {
        if (!el) {
          return;
        }
        if (value === null || value === undefined || value === "") {
          el.textContent = fallback;
        } else {
          el.textContent = value;
        }
      };

      const updateStatus = (status) => {
        if (!statusEl) {
          return;
        }
        statusEl.textContent = status || "-";
        const className = statusClasses[status] || "status-idle";
        statusEl.className = `status ${className}`;
      };

      const updateOutput = (output) => {
        const value = output || "";
        const hasOutput = value.length > 0;
        if (outputEl) {
          outputEl.textContent = value;
        }
        if (outputRenderedEl) {
          if (window.llmctlMarkdown) {
            window.llmctlMarkdown.renderInto(outputRenderedEl, value);
          } else {
            outputRenderedEl.textContent = value;
          }
          outputRenderedEl.style.display = hasOutput ? "" : "none";
        }
        if (outputEmptyEl) {
          outputEmptyEl.style.display = hasOutput ? "none" : "";
        }
        if (outputCopyButton) {
          outputCopyButton.disabled = !hasOutput;
        }
        return hasOutput;
      };

      const updateStages = (entries, currentStage, taskStatus) => {
        if (!Array.isArray(entries)) {
          return;
        }
        entries.forEach((entry) => {
          if (!entry || !entry.key) {
            return;
          }
          const nodes = stageNodes.get(entry.key);
          if (!nodes) {
            return;
          }
          if (nodes.statusEl) {
            nodes.statusEl.textContent =
              entry.status_label || entry.status || "-";
            if (entry.status_class) {
              nodes.statusEl.className = `status ${entry.status_class}`;
            }
          }
          const logsText = entry.logs || "";
          const hasLogs = logsText.length > 0;
          if (nodes.logsEl) {
            if (window.llmctlMarkdown) {
              window.llmctlMarkdown.renderInto(nodes.logsEl, logsText);
            } else {
              nodes.logsEl.textContent = logsText;
            }
            nodes.logsEl.style.display = hasLogs ? "" : "none";
          }
          if (nodes.emptyEl) {
            nodes.emptyEl.style.display = hasLogs ? "none" : "";
          }
          if (
            entry.key === currentStage &&
            taskStatus === "running" &&
            nodes.logsEl &&
            hasLogs
          ) {
            nodes.logsEl.scrollTop = nodes.logsEl.scrollHeight;
          }
        });
      };

      let pollTimer = null;
      let polling = false;
      let hadOutput = Boolean((outputEl?.textContent || "").length > 0);
      let realtimeClient = null;

      const schedulePoll = () => {
        if (!polling) {
          return;
        }
        pollTimer = window.setTimeout(poll, 1000);
      };

      const stopPolling = () => {
        polling = false;
        if (pollTimer) {
          window.clearTimeout(pollTimer);
          pollTimer = null;
        }
      };

      const startPollingFallback = (reason = "") => {
        if (polling) {
          return;
        }
        polling = true;
        if (autoRefreshEl) {
          autoRefreshEl.style.display = "";
          autoRefreshEl.textContent = reason
            ? `Realtime unavailable (${reason}). Falling back to 1s polling.`
            : "Realtime unavailable. Falling back to 1s polling.";
        }
        poll();
      };

      const applyTaskPayload = (data) => {
        if (!data || typeof data !== "object") {
          return;
        }
        updateStatus(data.status);
        updateText(startedAtEl, data.started_at);
        updateText(finishedAtEl, data.finished_at);
        updateText(createdAtEl, data.created_at);
        updateText(runTaskIdEl, data.run_task_id);
        updateText(celeryIdEl, data.celery_task_id);
        const hasOutput = updateOutput(data.output);
        updateStages(data.stage_entries, data.current_stage, data.status);
        root.setAttribute("data-task-status", data.status || "");
        if (outputDetailsEl && hasOutput && !hadOutput && !outputDetailsEl.open) {
          outputDetailsEl.open = true;
        }
        hadOutput = hasOutput;
        if (!["queued", "running"].includes(String(data.status || ""))) {
          stopPolling();
          if (realtimeClient) {
            realtimeClient.disconnect();
            realtimeClient = null;
          }
          if (autoRefreshEl) {
            autoRefreshEl.style.display = "none";
          }
        }
      };

      const fetchTaskStatus = async () => {
        if (!statusUrl) {
          throw new Error("Missing status URL.");
        }
        const response = await window.fetch(statusUrl, {
          cache: "no-store",
          headers: {
            Accept: "application/json",
          },
        });
        if (!response.ok) {
          throw new Error("Failed to fetch node status.");
        }
        return response.json();
      };

      const poll = async () => {
        if (!polling) {
          return;
        }
        try {
          const data = await fetchTaskStatus();
          applyTaskPayload(data);
        } catch (error) {
          schedulePoll();
          return;
        }
        schedulePoll();
      };

      const taskId = Number(root.getAttribute("data-task-id") || "0");

      const refreshFromSocketEvent = async () => {
        try {
          const data = await fetchTaskStatus();
          applyTaskPayload(data);
        } catch (_error) {
          // Socket events will trigger additional attempts; fallback polling handles persistent failures.
        }
      };

      const startRealtime = () => {
        if (
          !window.llmctlRealtime ||
          typeof window.llmctlRealtime.connect !== "function" ||
          !Number.isInteger(taskId) ||
          taskId <= 0
        ) {
          startPollingFallback("helper unavailable");
          return;
        }
        realtimeClient = window.llmctlRealtime.connect({
          roomKeys: [`task:${taskId}`],
          onSocketReady: () => {
            stopPolling();
            if (autoRefreshEl) {
              autoRefreshEl.style.display = "";
              autoRefreshEl.textContent = "Realtime updates active.";
            }
          },
          onSocketFailure: (reason) => {
            startPollingFallback(String(reason || "socket failure"));
          },
          onEvent: (eventName, envelope) => {
            const payload = envelope && typeof envelope === "object" ? envelope : {};
            const eventType = String(payload.event_type || eventName || "").trim();
            const entityId = Number(payload.entity_id || "0");
            if (!eventType.startsWith("node.task.") || entityId !== taskId) {
              return;
            }
            refreshFromSocketEvent();
          },
        });
        if (!realtimeClient) {
          startPollingFallback("socket connection unavailable");
        }
      };

      refreshFromSocketEvent();
      startRealtime();
      window.addEventListener("beforeunload", () => {
        stopPolling();
        if (realtimeClient) {
          realtimeClient.disconnect();
          realtimeClient = null;
        }
      });
    })();
  </script>
{% endif %}
{% endblock %}
