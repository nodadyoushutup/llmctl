{% extends "base.html" %}

{% block topbar_actions %}
  <a class="btn btn-secondary" href="{{ url_for('agents.runs') }}">
    <i class="fa-solid fa-arrow-left"></i>
    back to autoruns
  </a>
{% endblock %}

{% block action_header %}
  <div class="action-header-actions">
    <a class="btn btn-secondary" href="{{ url_for('agents.view_agent', agent_id=agent.id) }}">
      <i class="fa-solid fa-robot"></i>
      view agent
    </a>
    {% if run.status in ["running", "starting", "stopping"] %}
      <form method="post" action="{{ url_for('agents.stop_agent', agent_id=agent.id) }}">
        <input type="hidden" name="next" value="{{ request.path }}" />
        <button type="submit" class="btn btn-danger">
          <i class="fa-solid fa-stop"></i>
          stop autorun
        </button>
      </form>
    {% endif %}
  </div>
{% endblock %}

{% block content %}
<section class="card">
  <div class="card-header">
    <div>
      <p class="eyebrow">autorun</p>
      <h2 class="section-title">{{ run.name or ("Autorun for " ~ agent.name) }}</h2>
    </div>
  </div>
  <p class="muted" style="margin-top: 12px;">
    Autoruns are created automatically when you enable autorun on the agent.
  </p>
  <div style="margin-top: 20px; overflow-x: auto;">
    <table class="table">
      <thead>
        <tr>
          <th>Agent</th>
          <th>Status</th>
          <th>Autorun ID</th>
          <th>Autorun node</th>
          <th>Autorun mode</th>
          <th>Loops completed</th>
          <th>Remaining</th>
          <th>Last started</th>
          <th>Last stopped</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <a href="{{ url_for('agents.view_agent', agent_id=agent.id) }}">
              {{ agent.name }}
            </a>
          </td>
          <td>
            {% if run.status in ["running", "starting"] %}
              <span class="status status-running">active</span>
            {% elif run.status == "stopping" %}
              <span class="status status-warning">stopping</span>
            {% elif run.status == "error" %}
              <span class="status status-failed">error</span>
            {% else %}
              <span class="status status-idle">off</span>
            {% endif %}
          </td>
          <td>{{ run.id }}</td>
          <td class="muted">{{ run_task_id or "-" }}</td>
          <td>
            {% if run_is_forever %}
              forever
            {% else %}
              limit {{ run_max_loops }}
            {% endif %}
          </td>
          <td>{{ loops_completed }}</td>
          <td>
            {% if loops_remaining is none %}
              -
            {% else %}
              {{ loops_remaining }}
            {% endif %}
          </td>
          <td class="muted">{{ human_time(run.last_started_at) }}</td>
          <td class="muted">{{ human_time(run.last_stopped_at) }}</td>
        </tr>
      </tbody>
    </table>
  </div>
  {% if run.run_end_requested %}
    <p class="muted" style="margin-top: 12px;">
      End requested. This autorun will stop after the current node run finishes.
    </p>
  {% endif %}
  {% if run.status in ["running", "starting", "stopping"] %}
    <p class="muted" style="margin-top: 12px;">
      Realtime updates active. Timed reload fallback starts only if socket connectivity fails.
    </p>
  {% endif %}
</section>

<section class="card">
  <div class="card-header">
    <h2 class="section-title">Node Runs</h2>
  </div>
  {% if run_tasks %}
    <div style="margin-top: 20px; overflow-x: auto;">
      <table class="table">
        <thead>
          <tr>
            <th>Node</th>
            <th>Status</th>
            <th>Runtime</th>
            <th>Dispatch / Fallback</th>
            <th>Started</th>
            <th>Finished</th>
          </tr>
        </thead>
        <tbody>
          {% for task in run_tasks %}
            <tr
              class="table-row-link"
              data-href="{{ url_for('agents.view_node', task_id=task.id) }}"
            >
              <td>
                <a href="{{ url_for('agents.view_node', task_id=task.id) }}">
                  {{ task.id }}
                </a>
              </td>
              <td>
                {% if task.status == "running" %}
                  <span class="status status-running">running</span>
                {% elif task.status == "queued" %}
                  <span class="status status-queued">queued</span>
                {% elif task.status == "pending" %}
                  <span class="status status-queued">pending</span>
                {% elif task.status == "succeeded" %}
                  <span class="status status-success">succeeded</span>
                {% elif task.status == "failed" %}
                  <span class="status status-failed">failed</span>
                {% else %}
                  <span class="status status-idle">{{ task.status }}</span>
                {% endif %}
              </td>
              <td>
                <p class="muted" style="margin: 0; font-size: 12px;">
                  {{ task.provider_route or "-" }}
                </p>
                <p class="muted" style="margin: 4px 0 0; font-size: 12px;">
                  dispatch id: {{ task.provider_dispatch_id or "-" }}
                </p>
                <p class="muted" style="margin: 4px 0 0; font-size: 12px;">
                  workspace: {{ task.workspace_identity or "-" }}
                </p>
              </td>
              <td>
                <p class="muted" style="margin: 0; font-size: 12px;">
                  {{ task.dispatch_status or "-" }}
                  {% if task.dispatch_uncertain %}
                    (uncertain)
                  {% endif %}
                </p>
                {% if task.fallback_attempted %}
                  <p class="muted" style="margin: 4px 0 0; font-size: 12px;">
                    fallback: {{ task.fallback_reason or "unknown" }}
                  </p>
                {% endif %}
                {% if task.api_failure_category %}
                  <p class="muted" style="margin: 4px 0 0; font-size: 12px;">
                    api failure: {{ task.api_failure_category }}
                  </p>
                {% endif %}
                {% if task.cli_fallback_used %}
                  <p class="muted" style="margin: 4px 0 0; font-size: 12px;">
                    cli fallback: {{ "preflight ok" if task.cli_preflight_passed else "preflight unknown" }}
                  </p>
                {% endif %}
              </td>
              <td class="muted">{{ task.started_at or "-" }}</td>
              <td class="muted">{{ task.finished_at or "-" }}</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  {% else %}
    <p class="muted" style="margin-top: 12px;">No node runs recorded for this autorun yet.</p>
  {% endif %}
</section>

{% if run.status in ["running", "starting", "stopping"] %}
  <script>
    (() => {
      const runId = Number("{{ run.id }}");
      const fallbackDelayMs = 5000;
      let fallbackTimer = null;
      let fallbackEnabled = false;
      let reloadPending = false;
      let realtimeController = null;

      const scheduleReload = (delayMs = 120) => {
        if (reloadPending) {
          return;
        }
        reloadPending = true;
        window.setTimeout(() => {
          window.location.reload();
        }, delayMs);
      };

      const scheduleFallbackReload = () => {
        if (!fallbackEnabled) {
          return;
        }
        fallbackTimer = window.setTimeout(() => {
          scheduleReload(0);
        }, fallbackDelayMs);
      };

      const startFallback = () => {
        if (fallbackEnabled) {
          return;
        }
        fallbackEnabled = true;
        scheduleFallbackReload();
      };

      const stopFallback = () => {
        fallbackEnabled = false;
        if (fallbackTimer) {
          window.clearTimeout(fallbackTimer);
          fallbackTimer = null;
        }
      };

      if (!window.llmctlRealtime || typeof window.llmctlRealtime.connect !== "function") {
        startFallback();
        return;
      }

      realtimeController = window.llmctlRealtime.connect({
        roomKeys: [`run:${runId}`],
        onSocketReady: () => {
          stopFallback();
        },
        onSocketFailure: () => {
          startFallback();
        },
        onEvent: (eventName, envelope) => {
          const data = envelope && typeof envelope === "object" ? envelope : {};
          const eventType = String(data.event_type || eventName || "").trim();
          if (!eventType.startsWith("node.task.")) {
            return;
          }
          const rooms = Array.isArray(data.room_keys) ? data.room_keys : [];
          if (!rooms.includes(`run:${runId}`)) {
            return;
          }
          scheduleReload();
        },
      });

      if (!realtimeController) {
        startFallback();
        return;
      }

      window.addEventListener("beforeunload", () => {
        stopFallback();
        if (realtimeController) {
          realtimeController.disconnect();
          realtimeController = null;
        }
      });
    })();
  </script>
{% endif %}

<script>
  const runTaskRows = document.querySelectorAll(".table-row-link");
  const isInteractiveTarget = (target) =>
    target.closest(
      "a, button, input, select, textarea, label, summary, details"
    );
  runTaskRows.forEach((row) => {
    row.addEventListener("click", (event) => {
      if (isInteractiveTarget(event.target)) {
        return;
      }
      const href = row.dataset.href;
      if (href) {
        window.location.href = href;
      }
    });
  });
</script>
{% endblock %}
